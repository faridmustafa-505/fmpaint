<!DOCTYPE html>
<html lang="az">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Face Controller Game</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body {
            background-color: #000;
            color: #00ffcc;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            touch-action: none;
            user-select: none;
        }

        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        .input_video { display: none; }
        .output_canvas { width: 100%; height: 100%; object-fit: cover; }

        /* UI Overlay */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .score-board {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 2rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px #00ffcc;
        }

        .menu-box {
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #00ffcc;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            pointer-events: auto;
            box-shadow: 0 0 50px rgba(0, 255, 204, 0.3);
            backdrop-filter: blur(10px);
        }

        .btn {
            background: #00ffcc;
            color: #000;
            border: none;
            padding: 15px 40px;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 20px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px #00ffcc;
        }

        .hidden { display: none !important; }

        .tutorial {
            margin-top: 10px;
            color: #ccc;
            font-size: 0.9rem;
        }

    </style>
</head>
<body>

    <div class="game-container">
        <!-- Video M…ônb…ôyi -->
        <video class="input_video" playsinline webkit-playsinline></video>
        <!-- Oyun Sah…ôsi -->
        <canvas class="output_canvas"></canvas>

        <!-- UI -->
        <div class="score-board hidden" id="score-display">0</div>

        <div class="ui-layer" id="menu-layer">
            <div class="menu-box" id="start-screen">
                <h1 class="text-4xl text-teal-400 font-bold mb-2">NEON RUSH</h1>
                <p class="text-white mb-4">Ba≈üƒ±nla idar…ô et!</p>
                <div class="tutorial">
                    üü¢ Ya≈üƒ±l = Xal (+10)<br>
                    üî¥ Qƒ±rmƒ±zƒ± = Oyun Bitir<br>
                    Ba≈üƒ±nƒ± saƒüa-sola …ôy…ôr…ôk g…ômini s√ºr.
                </div>
                <button class="btn" onclick="startGame()">OYNA</button>
            </div>

            <div class="menu-box hidden" id="game-over-screen">
                <h1 class="text-3xl text-red-500 font-bold mb-2">OYUN Bƒ∞TDƒ∞!</h1>
                <p class="text-2xl text-white mb-4">N…ôtic…ô: <span id="final-score">0</span></p>
                <button class="btn" onclick="startGame()">YENƒ∞D∆èN</button>
            </div>
        </div>
    </div>

    <script>
        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementsByClassName('output_canvas')[0];
        const ctx = canvasElement.getContext('2d', { alpha: false });

        // UI Elements
        const scoreDisplay = document.getElementById('score-display');
        const menuLayer = document.getElementById('menu-layer');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreEl = document.getElementById('final-score');

        // Game State
        let gameState = 'MENU'; // MENU, PLAYING, GAMEOVER
        let score = 0;
        let playerX = 0.5; // 0.0 to 1.0
        let gameSpeed = 3;
        let items = []; // Objects falling down
        let frameCount = 0;

        function resizeCanvas() {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function startGame() {
            gameState = 'PLAYING';
            score = 0;
            gameSpeed = 4; // Start speed
            items = [];
            scoreDisplay.innerText = score;
            
            // UI Updates
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            scoreDisplay.classList.remove('hidden');
            menuLayer.classList.add('hidden'); // Hide overlay container so clicks don't block
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            finalScoreEl.innerText = score;
            menuLayer.classList.remove('hidden');
            gameOverScreen.classList.remove('hidden');
            scoreDisplay.classList.add('hidden');
        }

        function spawnItem() {
            const type = Math.random() > 0.3 ? 'BAD' : 'GOOD'; // 70% Bad, 30% Good
            items.push({
                x: Math.random(), // 0.0 to 1.0
                y: -0.1, // Start above screen
                type: type,
                size: type === 'BAD' ? 0.08 : 0.06 // Relative size
            });
        }

        function updateGameLogic(aspectRatio) {
            // Spawn items
            if (frameCount % 40 === 0) { // Every ~1.5 seconds
                spawnItem();
                // Speed up slightly
                if (gameSpeed < 15) gameSpeed += 0.05;
            }
            frameCount++;

            // Move & Check Collisions
            for (let i = items.length - 1; i >= 0; i--) {
                let item = items[i];
                
                // Move down (speed adjusted by screen height roughly)
                item.y += gameSpeed / 1000; 

                // Draw Item Logic is handled in draw section, but logic is here
                // Collision Detection
                // Player is at playerX, y = 0.85
                const playerY = 0.85;
                const hitDistX = 0.1; // Hitbox width
                const hitDistY = 0.1; // Hitbox height

                // Simple box collision in normalized coordinates
                if (item.y > playerY - hitDistY/2 && item.y < playerY + hitDistY/2) {
                    if (Math.abs(item.x - playerX) < hitDistX) {
                        // HIT!
                        if (item.type === 'GOOD') {
                            score += 10;
                            scoreDisplay.innerText = score;
                            // Remove item
                            items.splice(i, 1);
                            continue;
                        } else {
                            // BAD ITEM
                            gameOver();
                            return;
                        }
                    }
                }

                // Remove if off screen
                if (item.y > 1.1) {
                    items.splice(i, 1);
                }
            }
        }

        function drawGame(canvasWidth, canvasHeight) {
            // 1. Draw Player (Triangle/Ship)
            const px = playerX * canvasWidth; // Flip logic handled before? No, playerX comes from mirrored video usually
            const py = canvasHeight * 0.85;
            const size = 40;

            ctx.beginPath();
            ctx.moveTo(px, py - size);
            ctx.lineTo(px - size, py + size);
            ctx.lineTo(px + size, py + size);
            ctx.fillStyle = '#00ffcc';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#00ffcc';
            ctx.fill();
            ctx.shadowBlur = 0;

            // 2. Draw Items
            items.forEach(item => {
                const ix = item.x * canvasWidth;
                const iy = item.y * canvasHeight;
                const iSize = item.size * canvasWidth; // Scale by width

                ctx.beginPath();
                if (item.type === 'GOOD') {
                    // Green Ball
                    ctx.arc(ix, iy, iSize/2, 0, Math.PI * 2);
                    ctx.fillStyle = '#00ff00';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00ff00';
                } else {
                    // Red Spike/Virus
                    ctx.moveTo(ix, iy - iSize/2);
                    ctx.lineTo(ix + iSize/2, iy + iSize/2);
                    ctx.lineTo(ix - iSize/2, iy + iSize/2);
                    ctx.fillStyle = '#ff0000';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff0000';
                }
                ctx.fill();
                ctx.shadowBlur = 0;
            });
        }

        function onResults(results) {
            // 1. Draw Video Background
            ctx.save();
            ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            // Mirror image for natural feel
            ctx.translate(canvasElement.width, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            ctx.restore();

            // Darken filter
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(0, 0, canvasElement.width, canvasElement.height);

            // 2. Detect Player Position (Nose)
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                const nose = landmarks[1]; // Nose tip
                
                // Update global player X (Mirror logic: 1 - x)
                // MediaPipe x is 0-1 from left to right.
                // Since we mirrored the canvas draw, we also need to treat input as mirrored for logic if we want "moving right moves right".
                // Actually, if I move head right, x increases. 
                // Let's just use 1-nose.x to match the mirrored video.
                playerX = 1 - nose.x;
            }

            // 3. Game Logic Loop (Only if playing)
            if (gameState === 'PLAYING') {
                updateGameLogic(canvasElement.width / canvasElement.height);
                drawGame(canvasElement.width, canvasElement.height);
            }
        }

        const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: false,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        faceMesh.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => await faceMesh.send({image: videoElement}),
            width: 640, // Low res for performance
            height: 480,
            facingMode: 'user'
        });
        camera.start();

    </script>
</body>
</html>
